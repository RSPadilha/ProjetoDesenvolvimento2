import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { AuthService } from '../../services/auth.service';

interface TipoServico {
   id: number;
   nome: string;
   descricao: string;
   precoBase: number;
}

interface Endereco {
   id: number;
   rua: string;
   numero: string;
   complemento?: string;
   bairro: string;
   cidade: string;
   estado: string;
   cep: string;
}

interface Pedido {
   id?: number;
   idCliente: string;
   idServico: number;
   descricao: string;
   idEndereco: number;
   dataCriacao: string;
   status: string;
   valor?: number;
   // Campos para exibi칞칚o
   nome_servico?: string;
   endereco_completo?: string;
}

interface NovoPedidoForm {
   idServico: number | null;
   descricao: string;
   idEndereco: number | null;
}

interface MensagemChat {
   id: string;
   texto: string;
   tipo: 'user' | 'support';
   timestamp: Date;
}

@Component({
   selector: 'app-cliente',
   standalone: true,
   imports: [CommonModule, FormsModule, RouterModule],
   templateUrl: './cliente.component.html',
   styleUrl: './cliente.component.css'
})
export class ClienteComponent implements OnInit {
   pedidos: any[] = [];
   tiposServico: TipoServico[] = [];
   enderecos: Endereco[] = [];
   loading = false;
   usuarioId: string | null = null;
   private apiUrl = 'https://frameworks-dev-web-i-1.onrender.com/api';

   // Propriedades do chat
   chatAberto = false;
   mensagensChat: MensagemChat[] = [];
   novaMensagem = '';
   enviandoMensagem = false;

   // Formul치rio para novo pedido
   novoPedidoForm: NovoPedidoForm = {
      idServico: null,
      descricao: '',
      idEndereco: null
   };

   constructor(private http: HttpClient, private authService: AuthService) { }

   async ngOnInit() {
      await this.carregarUsuario();

      // S칩 carrega os dados se o usu치rio foi carregado com sucesso
      if (this.usuarioId) {
         await this.carregarTiposServico();
         await this.carregarEnderecos();
         await this.carregarPedidos();
      }
   }

   async carregarUsuario() {
      try {
         // Obter o usu치rio logado do Supabase
         const user = await this.authService.getCurrentUser();

         if (!user || !user.email) {
            console.error('Usu치rio n칚o est치 logado ou n칚o tem e-mail');
            return;
         }

         console.log('E-mail do usu치rio logado:', user.email);

         // Fazer requisi칞칚o para obter todos os usu치rios usando Promise
         const usuarios = await new Promise<any[]>((resolve, reject) => {
            this.http.get<any[]>(`${this.apiUrl}/usuarios`).subscribe({
               next: (data) => resolve(data),
               error: (error) => reject(error)
            });
         });

         // Encontrar o usu치rio com o mesmo e-mail
         const usuarioEncontrado = usuarios.find(u => u.email === user.email);

         if (usuarioEncontrado) {
            this.usuarioId = usuarioEncontrado.id.toString();
            console.log('ID do usu치rio na tabela usuarios:', this.usuarioId);
         } else {
            console.error('Usu치rio n칚o encontrado na tabela usuarios');
            this.usuarioId = null;
         }
      } catch (error) {
         console.error('Erro ao carregar usu치rio:', error);
         this.usuarioId = null;
      }
   }

   async carregarTiposServico() {
      try {
         this.http.get<any[]>(`${this.apiUrl}/servicos`).subscribe({
            next: (data) => {
               this.tiposServico = data || [];
            },
            error: (error) => {
               console.error('Erro ao carregar tipos de servi칞o:', error);
               this.tiposServico = [];
            }
         });
      } catch (error) {
         console.error('Erro ao carregar tipos de servi칞o:', error);
         this.tiposServico = [];
      }
   }

   async carregarEnderecos() {
      if (!this.usuarioId) return;

      try {
         // Fazer requisi칞칚o usando o ID da tabela usuarios
         this.http.get<any[]>(`${this.apiUrl}/enderecos/usuario/${this.usuarioId}`).subscribe({
            next: (data) => {
               this.enderecos = data || [];
               console.log('Endere칞os carregados:', this.enderecos);
            },
            error: (error) => {
               console.error('Erro ao carregar endere칞os:', error);
               this.enderecos = [];
            }
         });
      } catch (error) {
         console.error('Erro ao carregar endere칞os:', error);
         this.enderecos = [];
      }
   }

   async carregarPedidos() {
      if (!this.usuarioId) return;

      try {
         // Buscar todos os pedidos e filtrar pelo cliente
         this.http.get<any[]>(`${this.apiUrl}/pedidos`).subscribe({
            next: (todosPedidos) => {
               // Filtrar pedidos do usu치rio atual
               const pedidosDoUsuario = todosPedidos.filter(p => p.idCliente.toString() === this.usuarioId);

               if (pedidosDoUsuario.length === 0) {
                  this.pedidos = [];
                  console.log('Nenhum pedido encontrado para o usu치rio');
                  return;
               }

               // Mapear pedidos usando as informa칞칫es j치 retornadas pela API
               this.pedidos = pedidosDoUsuario.map((pedido: any) => ({
                  ...pedido,
                  nome_servico: pedido.servico || 'Servi칞o n칚o encontrado',
                  endereco_completo: pedido.endereco || 'Endere칞o n칚o encontrado'
               }));

               console.log('Pedidos carregados:', this.pedidos);
            },
            error: (error) => {
               console.error('Erro ao carregar pedidos:', error);
               this.pedidos = [];
            }
         });
      } catch (error) {
         console.error('Erro ao carregar pedidos:', error);
         this.pedidos = [];
      }
   }

   async recarregarEnderecos() {
      await this.carregarEnderecos();
   }

   async novoPedido() {
      if (!this.usuarioId || !this.novoPedidoForm.idServico || !this.novoPedidoForm.idEndereco || !this.novoPedidoForm.descricao.trim()) {
         alert('Por favor, preencha todos os campos obrigat칩rios.');
         return;
      }

      this.loading = true;

      try {
         const novoPedido = {
            idCliente: this.usuarioId,
            idServico: this.novoPedidoForm.idServico,
            descricao: this.novoPedidoForm.descricao.trim(),
            idEndereco: this.novoPedidoForm.idEndereco,
            dataCriacao: new Date().toISOString(),
            status: 'pendente'
         };

         this.http.post<any>(`${this.apiUrl}/pedidos`, novoPedido).subscribe({
            next: (data) => {
               // Limpar formul치rio
               this.novoPedidoForm = {
                  idServico: null,
                  descricao: '',
                  idEndereco: null
               };

               // Recarregar pedidos
               this.carregarPedidos();
               alert('Pedido criado com sucesso!');
            },
            error: (error) => {
               console.error('Erro ao criar pedido:', error);
               alert('Erro ao criar pedido. Tente novamente.');
            },
            complete: () => {
               this.loading = false;
            }
         });
      } catch (error: any) {
         console.error('Erro ao criar pedido:', error);
         alert('Erro ao criar pedido. Tente novamente.');
      } finally {
         this.loading = false;
      }
   }

   formatarData(data: string): string {
      return new Date(data).toLocaleDateString('pt-BR');
   }

   getEnderecoCompleto(enderecoId: number): string {
      const endereco = this.enderecos.find(e => e.id === enderecoId);
      if (!endereco) return '';

      return `${endereco.rua}, ${endereco.numero}${endereco.complemento ? ' - ' + endereco.complemento : ''} - ${endereco.bairro}, ${endereco.cidade}/${endereco.estado}`;
   }

   // M칠todos do Chat
   toggleChat(): void {
      this.chatAberto = !this.chatAberto;

      // Se abriu o chat e n칚o tem mensagens, adicionar mensagem de boas-vindas
      if (this.chatAberto && this.mensagensChat.length === 0) {
         setTimeout(() => {
            this.adicionarMensagemSupporte('Ol치! Como posso ajud치-lo hoje? 游땕');
         }, 500);
      }
   }

   enviarMensagem(): void {
      if (!this.novaMensagem.trim() || this.enviandoMensagem) return;

      const textoMensagem = this.novaMensagem.trim();

      // Adicionar mensagem do usu치rio
      this.adicionarMensagemUsuario(textoMensagem);

      // Limpar input
      this.novaMensagem = '';

      // Simular resposta do suporte
      this.simularRespostaSupporte(textoMensagem);
   }

   private adicionarMensagemUsuario(texto: string): void {
      const mensagem: MensagemChat = {
         id: this.gerarIdMensagem(),
         texto: texto,
         tipo: 'user',
         timestamp: new Date()
      };
      this.mensagensChat.push(mensagem);
      this.scrollParaUltimaMensagem();
   }

   private adicionarMensagemSupporte(texto: string): void {
      const mensagem: MensagemChat = {
         id: this.gerarIdMensagem(),
         texto: texto,
         tipo: 'support',
         timestamp: new Date()
      };
      this.mensagensChat.push(mensagem);
      this.scrollParaUltimaMensagem();
   }

   private simularRespostaSupporte(mensagemUsuario: string): void {
      this.enviandoMensagem = true;

      setTimeout(() => {
         let resposta = this.gerarRespostaAutomatica(mensagemUsuario);
         this.adicionarMensagemSupporte(resposta);
         this.enviandoMensagem = false;
      }, 1000 + Math.random() * 2000); // Simular delay de 1-3 segundos
   }

   private gerarRespostaAutomatica(mensagem: string): string {
      const mensagemLower = mensagem.toLowerCase();

      if (mensagemLower.includes('pedido') || mensagemLower.includes('solicita칞칚o')) {
         return 'Posso ajud치-lo com quest칫es sobre pedidos! Voc칡 pode acompanhar o status dos seus pedidos na tabela acima. H치 algo espec칤fico que gostaria de saber?';
      }

      if (mensagemLower.includes('endere칞o') || mensagemLower.includes('endereco')) {
         return 'Para cadastrar ou editar endere칞os, voc칡 pode acessar a se칞칚o "Minha Conta" clicando no link acima. L치 voc칡 poder치 gerenciar todos os seus endere칞os.';
      }

      if (mensagemLower.includes('servi칞o') || mensagemLower.includes('servico')) {
         return 'Oferecemos diversos tipos de servi칞os! Voc칡 pode ver todos dispon칤veis no formul치rio de cria칞칚o de pedidos. Qual tipo de servi칞o voc칡 est치 interessado?';
      }

      if (mensagemLower.includes('valor') || mensagemLower.includes('pre칞o') || mensagemLower.includes('preco')) {
         return 'Os valores s칚o definidos ap칩s a an치lise de cada pedido. Um de nossos atendentes entrar치 em contato para passar o or칞amento detalhado.';
      }

      if (mensagemLower.includes('ol치') || mensagemLower.includes('oi') || mensagemLower.includes('bom dia') || mensagemLower.includes('boa tarde')) {
         return 'Ol치! Fico feliz em poder ajud치-lo. Estou aqui para esclarecer d칰vidas sobre nossos servi칞os, pedidos e muito mais!';
      }

      if (mensagemLower.includes('obrigado') || mensagemLower.includes('valeu') || mensagemLower.includes('thanks')) {
         return 'Por nada! Estou sempre aqui para ajudar. Se tiver mais alguma d칰vida, n칚o hesite em perguntar! 游땕';
      }

      // Resposta padr칚o
      return 'Entendi sua mensagem! Para quest칫es mais espec칤ficas, recomendo entrar em contato com nosso suporte especializado. Posso ajud치-lo com informa칞칫es sobre pedidos, servi칞os e conta.';
   }

   private gerarIdMensagem(): string {
      return Date.now().toString() + Math.random().toString(36).substr(2, 9);
   }

   private scrollParaUltimaMensagem(): void {
      setTimeout(() => {
         const chatMessages = document.querySelector('.chat-messages');
         if (chatMessages) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
         }
      }, 100);
   }

   trackByMensagem(index: number, mensagem: MensagemChat): string {
      return mensagem.id;
   }

   formatarHora(timestamp: Date): string {
      return timestamp.toLocaleTimeString('pt-BR', {
         hour: '2-digit',
         minute: '2-digit'
      });
   }
}
